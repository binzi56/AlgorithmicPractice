# 字符串匹配
---
字符串匹配主要包含两种匹配模式;
**单模式串匹配算法**(一个串跟另一个串进行匹配):
* `BF`(`Brute Force`)
*
*
*

**多模式串匹配算法**(一个串中同时查找多个串):
* `Trie`树
* `AC`自动机

---

### 单模式串匹配算法
#### 1.1 BF算法
> `BF`算法(`Brute Force`)，中文叫作暴力匹配算法，也叫朴素匹配算法。常用于在一个主串`S`内查找一个子串`T`的出现位置。

尽管理论上，`BF`算法的时间复杂度很高，是`O(n*m)`，但在实际的开发中，它却是一个比较常用的字符串匹配算法。为什么这么说呢?原因有两点。
* 实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长;而且当**中途遇到不能匹配的字符就终止**了;所以，尽管理论上的最坏情况时间复杂度是`O(n*m)`，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。
* 朴素字符串匹配算法思想简单，代码实现也非常简单。**简单意味着不容易出错**，如果有bug也容易暴露和修复。在工程中，在满足性能要求的前提下，简单 是首选。这也是我们常说的[KISS](https://baike.baidu.com/item/KISS%E5%8E%9F%E5%88%99/3242383?fr=aladdin)(`Keep it Simple and Stupid`)设计原则。

code:
```
/*
 * 返回子串t在串s第一次出现的位置(从1开始)
 */
int patternMatch_BF(string s, string t)
{
     int i = 1, j = 1;
     while (i <=s.length()&& j <=t.length())//两个串都没扫描完
     {
         if (s[i-1] == t[j-1])//该位置上字符相等，就比较下一个字符
         {
             i++;
             j++;
         }
         else
         {
             i = i - j + 2; //否则，i为上次扫描位置的下一位置
             j = 1;          //j从1开始
         }

     }
     if (j > t.length())
         return (i - t.length());
     return -1;
}
```

附:
* [字符串/规则匹配常用算法学习](https://www.cnblogs.com/mysky007/p/13089539.html)
* [字符串匹配模板-BF/KMP](https://www.cnblogs.com/Emcikem/p/11331323.html)
