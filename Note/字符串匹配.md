# 字符串匹配
---
字符串匹配主要包含两种匹配模式;
**单模式串匹配算法**(一个串跟另一个串进行匹配):
* `BF`(`Brute Force`)
* `RK`(`Rabin-Karp`)
* `BM`(`Boyer-Moore`)
*

**多模式串匹配算法**(一个串中同时查找多个串):
* `Trie`树
* `AC`自动机

---

### 单模式串匹配算法
#### 1.1 BF算法
> `BF`算法(`Brute Force`)，中文叫作暴力匹配算法，也叫朴素匹配算法。常用于在一个主串`S`内查找一个子串`T`的出现位置。

尽管理论上，`BF`算法的时间复杂度很高，是`O(n*m)`，但在实际的开发中，它却是一个比较常用的字符串匹配算法。为什么这么说呢?原因有两点。
* 实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长;而且当**中途遇到不能匹配的字符就终止**了;所以，尽管理论上的最坏情况时间复杂度是`O(n*m)`，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。
* 朴素字符串匹配算法思想简单，代码实现也非常简单。**简单意味着不容易出错**，如果有bug也容易暴露和修复。在工程中，在满足性能要求的前提下，简单 是首选。这也是我们常说的[KISS](https://baike.baidu.com/item/KISS%E5%8E%9F%E5%88%99/3242383?fr=aladdin)(`Keep it Simple and Stupid`)设计原则。

code:
```
/*
 * 返回子串t在串s第一次出现的位置(从1开始)
 */
int patternMatch_BF(string s, string t)
{
     int i = 1, j = 1;
     while (i <=s.length()&& j <=t.length())//两个串都没扫描完
     {
         if (s[i-1] == t[j-1])//该位置上字符相等，就比较下一个字符
         {
             i++;
             j++;
         }
         else
         {
             i = i - j + 2; //否则，i为上次扫描位置的下一位置
             j = 1;          //j从1开始
         }

     }
     if (j > t.length())
         return (i - t.length());
     return -1;
}
```

#### 1.2 RK算法
`RK`(`Rabin-Karp`),是由它的两位发明者`Rabin`和`Karp`的名字来命名的。这个算法理解起来也不是很难。其实就是`BF`算法的升级版。
`RK`算法的思路是这样的：
我们通过哈希算法对主串中的 `n-m+1` 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了。

模式串哈希值与每个子串哈希值之间的比较的时间复杂度是 `O(1)`，总共需要比较 `n-m+1` 个子串的哈希值，所以，这部分的时间复杂度也是 `O(n)`。所以，`RK` 算法整体的时间复杂度就是 `O(n)`。

跟 `BF` 算法相比，效率提高了很多。不过这样的效率取决于哈希算法的设计方法，如果存在冲突的情况下，时间复杂度可能会退化。极端情况下，哈希算法大量冲突，时间复杂度就退化为 `O(n*m)`;

code:
```
int patternMatch_RK(string s, string t){
  int m = s.size(), n = t.size();
  int tag = 1314;

  unordered_map<string, int> map;

  for (int i = 0; i < m - n; i++) {
      string temp = s.substr(i, n);
      map[temp] = i + tag;
      printf("_%s\n", temp.c_str());
  }

  if (map[t] >= tag) {
      //成功找到
      return map[t] - tag;
  }

  return -1;
}
```

#### 1.3 BM算法
`BM`(`Boyer-Moore`)算法。它是一种非常高效的字符串匹配算法，有实验统计，它的性能是著名的`KMP`算法的`3`到`4`倍。`BM`算法的原理很复杂，比较难懂;

> `BM`算法思想的本质上就是在进行模式匹配的过程中，当模式串与主串的某个字符不匹配的时候，能够跳过一些肯定不会匹配的情况，将模式串往后多滑动几位。(`BF`,`BK`仅向后移动一位)

`BM`算法寻找是否能多滑动几位的原则有两种，分别是 **坏字符规则** 和 **好后缀规则**。

* 坏字符规则：当文本串中的某个字符跟模式串的某个字符不匹配时，我们称文本串中的这个失配字符为坏字符，此时模式串需要向右移动，**移动的位数 = 坏字符在模式串中的位置 - 坏字符在模式串中最右出现的位置**。此外，如果"坏字符"不包含在模式串之中，则最右出现位置为-1。
* 好后缀规则：当字符失配时，**后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置**，且如果好后缀在模式串中没有再次出现，则为-1。

code:
```
#include <cstdio>
#include <cstdlib>
#include <iostream>
using namespace std;
const int size = 256;
//将模式串字符使用hash表示
void generateBC(char b[], int m, int bc[]){
//b是模式串， m是模式串的长度， bc是散列表
//bc的下标是字符集的ASCII码，数组值是每个字符在模式串中出现的位置。
for(int i=0; i<size; i++){
bc[i]=-1;
}
for(int i=0; i<m; i++){
int ascii = (int)b[i];
bc[ascii] = i;
}
}
/*
求suffix数组和prefix数组
suffix数组的下标K表示后缀字串的长度，数组值对应存储的是，在模式串中跟好后缀{u}相匹配的子串{u*}
的起始下标值。
prefix数组是布尔型。来记录模式串的后缀字串是否能匹配模式串的前缀子串。

*/
void generateGS(char b[], int m, int suffix[], bool prefix[]){
for(int i=0; i<m;i++){
suffix[i] = -1;
prefix[i] = false;
}
for(int i=0; i<m-1; ++i){
int j = i;
int k =0; //公共后缀字串长度
while(j >=0 && b[j] == b[m-1-k]){
//与b[0, m-1]求公共后缀字串
--j;
++k;
suffix[k] = j+1; //j+1表示公共后缀字串在b[0,i]中的起始下标
}
if(j == -1) prefix[k] = true;//如果公共后缀字串也是模式串的前缀字串

}
}

//j表示坏字符对应的模式串中的字符下标，m是模式串的长度
//计算在好后缀规则下模式串向后移动的个数
int moveByGS(int j, int m, int suffix[], bool prefix[]){
int k= m-1-j; //好后缀的长度
if(suffix[k] != -1) return j - suffix[k] +1;
for(int r = j+2; r<= m-1; ++r){
if(prefix[m-r] == true){
return r;
}
}
return m;
}

//BM算法
int BM(char a[], int n, char b[], int m){
int suffix[m];
bool prefix[m];

int bc[size];//bc记录模式串中每个字符最后出现的位置

generateBC(b,m,bc); //构建字符串hash表
generateGS(b,m, suffix,prefix); //计算好后缀和好前缀数组

int i=0; //表示主串与模式串对齐的第一个字符
while(i<=n-m){
int j;
for(j=m-1; j>=0; j--){ //模式串从后往前匹配
if(a[i+j]!= b[j]) break; //坏字符对应的模式串下标是j,即i+j 位置是坏字符的位置si
}
if(j < 0){
return i; //匹配成功，返回主串与模式串第一个匹配的字符的位置
}
//这里x等同于将模式串往后滑动j-bc[(int)a[i+j]]位
//bc[(int)a[i+j]]表示主串中坏字符在模式串中出现的位置xi
int x = i + (j - bc[(int)a[i+j]]);

int y =0;
if(j < m-1){//如果有好后缀的话,计算在此情况下向后移动的位数y
y = moveByGS(j, m, suffix, prefix);
}
i = i + max(x, y); //i更新位可以后移较多的位置

}
return -1;
}

int main(){
char a[] = "aaaabaaba";
char b[] = "aaaa";
int i = BM(a,9,b,2);
printf("%d\n", i);
return 0;
}
```
**BM算法性能分析**
BM算法的内存消耗：整个算法使用了三个额外数组，其中`bc`数组的大小和字符集大小有关，`suffix`数组和`prefix`数组的大小和模式串长度`m`有关。
如果我们处理字符集很大的模式匹配问题，`bc`数组对内存消耗会比较多。好后缀规则和坏字符规则是独立的，如果对内存要求苛刻，那么可以只使用好后缀规则，不过效率也会下降一些。

小结:
`BM`算法核心思想是，利用模式串本身的特点，在模式串中某个字符与主串不能匹配的时候，将模式串往后多滑动几位，以此来减少不必要的字符比较，提高匹配 的效率。
`BM`算法构建的规则有两类，坏字符规则和好后缀规则。好后缀规则可以独立于坏字符规则使用。因为坏字符规则的实现比较耗内存，为了节省内存，我们可以只用好后缀规则来实现`BM`算法。

* [字符串匹配的Boyer-Moore算法(阮一峰)](http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html)

#### 1.4 KMP算法
`KMP`算法是根据三位作者(`D.E.Knuth`，`J.H.Morris`和`V.R.Pratt`)的名字来命名的，算法的全称是`Knuth Morris Pratt`算法，简称为`KMP`算法。

`KMP` 算法的核心思想，跟上一节讲的 `BM` 算法非常相近。我们假设主串是 `a`，模式串是 `b`。在模式串与主串匹配的过程中，当遇到不可匹配的字符的时候，我们希望找到一些规律，可以将模式串往后多滑动几位，跳过那些肯定不会匹配的情况。

code:
```
//str1为主串，str2为模式串
#include <iostream>
#include <string>
#include <vector>
using namespace std;
void getnext(const string &str2,vector<int> next)
{   next.clear();
    next.resize(str2.size());
    if (str2.length()== 1)
    {
        next[0]=-1;
        return ;
    }
    next[0]=-1;
    next[1]=0;
    int len= str2.length();
    int i=2,cn=0;//cn为最长前缀的后一个字符
    while(i<len)
    {
        if (str2[i-1]==str2[cn]) //如果前一个字符和cn对应的值相等
            next[i++]=++cn;//如果相等则此处的值为，cn+1
        else if (cn>0)
            cn=next[cn];//不等的话继续往前推
        else
            next[i++] =0;//不等的话并未没法往前推就变为0
    }

}
int kmp( const string &str1, const string &str2,vector<int> & next)
{
    int i1 = 0, i2 = 0;
    while (i1<str1.length() && i2<str2.length())
    {
        if (str1[i1]==str2[i2])//两者比对，相等则主串和模式串都加加
        {
            i1++;
            i2++;
        }
        else if (next[i2]==-1)//两者没有匹配则进一步判断i2是否还有回退的资格，如果等于-1说明已经退到头了，则只能i1++;
        {
            i1++;
        }
        else//还可以退，则i2回到到next数组指定的位置再进行比对
            i2=next[i2];
    }
    return i2 == str2.length()?i1-i2:-1;
    //如果str2已经扫描完了说明已经找到了，返回str1中找到的起始位置；如果没有扫描完说明没有找到返回-1；
}

int main()
{
    string str1,str2;
    cin>>str1>>str2;
    vector<int> next;
    int k;
    k=kmp(str1,str2,next);
    return k;
}
```

**KMP算法复杂度分析**
* 空间复杂度`O(m)`
`KMP`算法只需要一个额外的`next`数组，数组的大小跟模式串相同。所以空间复杂度是`O(m)`，`m`表示模式串的长度。
* 时间复杂度`O(m+n)`

### 多模式串匹配算法
#### 2.1 Trie树


* [字符串匹配的KMP算法(阮一峰)](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)

附:
* [字符串/规则匹配常用算法学习](https://www.cnblogs.com/mysky007/p/13089539.html)
* [字符串匹配模板-BF/KMP](https://www.cnblogs.com/Emcikem/p/11331323.html)
