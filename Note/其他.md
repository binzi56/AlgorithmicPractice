# 其他

### 跳表
链表加多级索引的结构，就是跳表(实现了基于链表的“二分查找”)。

> 跳表使用空间换时间的设计思路，通过构建多级索引来提高查询的效率，实现了基于链表的“二分查找”。
跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是`O(logn)`。 跳表的空间复杂度是`O(n)`。
不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。

**时间复杂度:**
在跳表中查询某个数据的时候，如果每一层都要遍历m个结点，那在跳表中查询一个数据的时间复杂度就是`O(m*logn)`。

那这个m的值是多少呢?按照前面这种索引结构，我们每一级索引都最多只需要遍历`3`个结点，也就是说`m=3`，为什么是`3`呢?
假设我们要查找的数据是`x`，在第k级索引中，我们遍历到`y`结点之后，发现`x`大于`y`，小于后面的结点`z`，所以我们通过`y`的`down`指针，从第`k`级索引下降到第`k-1`级索引。在第`k-1`级索引中，`y`和`z`之间只有`3`个结点(包含`y`和`z`)，所以，我们在`K-1`级索引中最多只需要遍历`3`个结点，依次类推，每一级索引都最多只需要遍历`3`个结点。

![跳表查询](../Resources/跳表查询.png)

通过上面的分析，我们得到`m=3`，所以在跳表中查询任意数据的时间复杂度就是`O(logn)`。这个查找的时间复杂度跟二分查找是一样的。换句话说，我们其实是基于单链表实现了二分查找;

**空间复杂度:**
比起单纯的单链表，跳表需要存储多级索引，肯定要消耗更多的存储空间。比如每两个节点建立索引，结点总和就是`n/2+n/4+n/8...+8+4+2=n-2`。所以，跳表的空间复杂度是`O(n)`。
如果我们增加节点建立索引，比之前的方法更节省索引结点存储空间。但是空间复杂度依然是`O(n)`;

实际上，在软件开发中，我们不必太在意索引占用的额外空间。原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间 就可以忽略了。

#### 跳表的操作
跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操
作，而且插入、删除操作的时间复杂度也是`O(logn)`(主要是查找到索引的操作耗时, 单链表插入、删除操作的时间复杂度为`O(1)`)。

**跳表索引动态更新**
红黑树、`AVL`树这样平衡二叉树，它们是通过左右旋的方式保持左右子树的大小平衡，而跳表是通过**随机函数**来维护前面提到的“平衡性”。

当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。如何选择加入哪些索引层呢?
我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值`K`，那我们就将这个结点添加到第一级到第`K`级这`K`级索引中。

**跳表和红黑树对比:**
* **跳表更容易代码实现**，虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。
* **跳表更加灵活**，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。
* 但是实际开发中，红黑树直接拿来用，因为**红黑树比跳表的出现要早一些**。很多编程语言中的`Map`类型都是通过红黑树来实现的。但是跳表并没有一个现成的实现，必须要自己实现。

### 并查集

### 布隆过滤器(`Bloom filter`)

### LRU
