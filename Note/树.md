# 树
### 前言
#### 1. 树的定义
　　[树](https://baike.baidu.com/item/%E6%A0%91/2699484?fr=aladdin)是一种数据结构，它是由n（n>=1）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：
* 每个结点有零个或多个子结点；
* 没有前驱的结点称为根结点；
* 每一个非根结点有且只有一个父结点；
* 除了根结点外，每个子结点可以分为m个不相交的子树；

#### 2. 基本术语
**根节点**:最顶层只有一个节点，称之为根节点，root节点。
**叶子节点**:如果每个节点下方没有任何分叉的话，就是叶子节点。
**节点的高度**:从某个节点出发，到叶子节点为止，最长简单路径上边的条数，称之为节点的高度。(从下往上度量)
**节点的深度**:从根节点root出发，到某个节点边的条数，称为该节点的深度。(从上往下度量)

![树基本概念](../Resources/树基本概念-高度-深度-层.png)

**叶子**：度为0的节点
**非终端节点或分支节点**：度不为零的节点；
**双亲节点或父节点**：若一个结点含有子节点，则这个节点称为其子节点的父节点；
**孩子节点或子节点**：一个节点含有的子树的根节点称为该节点的子节点；
**兄弟节点**：具有相同父节点的节点互称为兄弟节点；
**堂兄弟节点**：双亲在同一层的节点互为堂兄弟；
**节点的祖先**：从根到该节点所经分支上的所有节点；
**子孙**：以某节点为根的子树中任一节点都称为该节点的子孙；

#### 3. 树的分类
![树基本概念](../Resources/计算机科学中的树.jpg)

### 二叉树
#### 1. 定义
二叉树:每个节点至多有两个子节点的树称为二叉树。

**几种特殊的二叉树**
1. **满二叉树**（完美二叉树）：所有非叶子节点均有两个子节点，所有叶子节点必须在同一层上。节点数达到最大值。
2. **完全二叉树**：若设二叉树的深度为`h`，除第`h`层外，其它各层的节点数都达到最大值，第`h`层所有的节点都连续**集中在最左边**。
3. **完满二叉树**：所有非叶子节点的度都是`2`。

**如何存储一颗二叉树**
* 基于指针或者引用的二叉链式存储法
```
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```
每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我 们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。

* 基于数组的顺序存储法
如果节点X存储在数组中下标为i的位置，下标为`2 * i` 的位置存储的就是左子节点，下标为`2 * i + 1`的位置存储的就是右子节点。反过来，下标 为`i/2`的位置存储就是它的父节点。通过这种方式，我们只要知道根节点存储的位置(一般情况下，为了方便计算子节点，根节点会存储在下标为`1`的位置)，这样就可以通过下标计算，把整棵树都串起来。

完全二叉树仅仅“浪费”了一个下标为`0`的存储位置。如果是非完全二叉树，其实会浪费比较多的数组存储空间。而且堆其实就是一种完全二叉树，最常用的存储方式就是数组。

**二叉树的遍历**
 前序遍历:根节点 => 左子树 => 右子树
 中序遍历:左子树 => 根节点 => 右子树
 后序遍历:左子树 => 右子树 => 根节点

递归实现(时间复杂度是`O(n)`):
```
//前序遍历
void preorderHelper(TreeNode *node){
    if(node == nullptr) return;
    result.push_back(node->val);
    preorderHelper(node->left);
    preorderHelper(node->right);
}

//中序遍历
void inorderHelper(TreeNode *node){
    if(node == nullptr) return;
    inorderHelper(node->left);
    result.push_back(node->val);
    inorderHelper(node->right);
}

//后序遍历
void postorderHelper(TreeNode *node){
    if(node == nullptr) return;
    postorderHelper(node->left);
    postorderHelper(node->right);
    result.push_back(node->val);
}
```

#### 2. 二叉查找树(`Binary Search Tree`)
二叉查找树是二叉树中最常用的一种类型，也叫**二叉搜索树**。顾名思义，二叉查找树是为了实现快速查找而生的。不过，它不仅仅支持快速查找一个数据，还支持快速插入、删除一个数据。

二叉查找树特点:
1. 若左子树不空，则左子树上所有节点的值均小于它的根节点的值；
2. 若右子树不空，则右子树上所有节点的值均大于它的根节点的值；
3. 左、右子树也分别为二叉查找树；

二叉查找树的相关操作:
除了插入、删除、查找操作之外，二叉查找树中还可以支持快速地查找最大节点和最小节点、前驱节点和后继节点。

* [二叉搜索树实现](https://github.com/wangzheng0822/algo/blob/master/c-cpp/24_tree/binarysearchtree.c)

> **中序遍历**二叉查找树，可以**输出有序的数据序列**，时间复杂度是O(n)，非常高效。因此，二叉查找树也叫作二叉排序树。

**支持重复数据的二叉查找树**
* 二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。
* 每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。
   *  当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。删除同理;

**二叉查找树的时间复杂度分析**
如果根节点的左右子树极度不平衡，已经退化成了链表，那么查找的时间复杂度就变成了`O(n)`。
不管操作是插入、删除还是查找，时间复杂度其实都跟树的高度成正比，也就是`O(height)`。

**二叉查找树和散列表对比**
散列表的插入、删除、查找操作的时间复杂度可以做到常量级的`O(1)`，非常高效。而二叉查找树在比较平衡的情况下(平衡二叉查找树)，插入、删除、查找操作时间复杂度才是`O(logn)`，相对散列表，好像并没有什么优势，那为什么还要用二叉查找树呢?
* 第一，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在`O(n)`的时间复杂度内，输出有序的数据序列。
* 第二，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在`O(logn)`。
* 第三，笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比`logn`小，所以实际的查找速度可能不一定 比`O(logn)`快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。
* 第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。

最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。
综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。

### 多路查找树

### 堆
