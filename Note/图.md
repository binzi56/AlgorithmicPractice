# 图

### 图相关知识
图(`Graph`)是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：`G（V，E）`，其中，`G`表示一个图，`V`是图`G`中顶点的集合，`E`是图`G`中边的集合。在图中的数据元素，我们称之为顶点（`Vertex`），顶点集合有穷非空。在图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。

顶点的度(`degree`):就是跟顶点相连接的边的条数。
有向图:边有方向的图。
无向图:边没有方向的图。

顶点的入度(`In-degree`):有多少条边指向这个顶点。
出度(`Out-degree`):表示有多少条边是以这个顶点为起点指向其他顶点。

带权图(`weighted graph`):在带权图中，每条边都有一个权重(`weight`);

![带权图](../Resources/带权图.png)

稀疏图:有很少条边。
稠密图:有很多条边。

[树-基本术语](https://blog.csdn.net/Ontheroad_/article/details/72739380)

#### 图的存储
##### 邻接矩阵存储方法
图最直观的一种存储方法就是，邻接矩阵(`Adjacency Matrix`)。

邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点`i`与顶点`j`之间有边，我们就将`A[i][j]`和`A[j][i]`标记为`1`;对于有向图来说，如果顶点`i`到顶点`j`之间，有一条箭头从顶点`i`指向顶点`j`的边，那我们就将`A[i][j]`标记为`1`。同理，如果有一条箭头从顶点`j`指向顶点`i`的边，我们就将`A[j][i]`标记为`1`。对于带权图，数组中就存储相应的权重。

![邻接矩阵存储图](../Resources/邻接矩阵存储图.png)

优点:
* 简单,直观
* 查询效率高
   * 因为基于数组，所以在获取两个顶点的关系时，就非常高效。
* 方便矩阵运算
   * 用邻接矩阵的方式存储图，可以将很多图的运算**转换成矩阵之间的运算**。比如求解最短路径问题时会提到一个`Floyd-Warshall`算法，就是利用矩阵循环相乘若干次得到结果。

缺点:
* 浪费空间
   * 如果我们存储的是稀疏图(`Sparse Matrix`)，也就是说，顶点很多，但每个顶点的边并不多，那邻接矩阵的存储方法就更加浪费空间。

#### 邻接表存储方法
邻接表(`Adjacency List`):数组与链表相结合的存储方法。

![邻接表存储方法](../Resources/邻接表存储方法.png)

优点:
* 方便查找任意顶点的所有"邻接点"
* 节省存储空间
* 方便计算任意顶点的度
   * 对于无向图:是的
   * 对于有向图:只能计算"出度";需要构造"**逆邻接表**"(存储的边)来方便计算"入度"

缺点:
* 不方便查找

优化:
* 链表换成更加高效的动态数据结构=>比如平衡二叉查找树、跳表、散列表、红黑树等。

小结:
邻接矩阵存储方法的缺点是比较浪费空间，但是优点是查询效率高，而且方便矩阵运算。邻接表存储方法中每个顶点都对应一个链表，存储与其相连接的其他顶点。尽管邻接表的存储方式比较节省存储空间，但链表不方便查找，所以查询效率没有邻接矩阵存储方式高。针对这个问题，邻接表还有改进升级版，即将链表换成更加高效的动态数据结构，比如平衡二叉查找树、跳表、散列表、红黑树等。

### 关键路径

### 最小生成树

### 最短路径

### 拓扑排序
